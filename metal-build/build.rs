use std::{
    collections::hash_map::DefaultHasher,
    env,
    fmt::Debug,
    hash::{Hash, Hasher},
    path::{Path, PathBuf},
};

use bindgen::{callbacks::ParseCallbacks, CargoCallbacks};

const METAL_BUILD_MANIFEST_DIR: &'static str = env!("CARGO_MANIFEST_DIR");

static mut ITEMS: Vec<String> = Vec::new();

#[derive(Debug)]
struct CollectItems {
    cargo_callbacks: CargoCallbacks,
}

impl CollectItems {
    fn new() -> Self {
        Self {
            cargo_callbacks: CargoCallbacks,
        }
    }
}

impl ParseCallbacks for CollectItems {
    fn include_file(&self, filename: &str) {
        self.cargo_callbacks.include_file(filename);
    }
    fn item_name(&self, item_name: &str) -> Option<String> {
        if item_name != "root" {
            unsafe {
                let item_name = item_name.to_owned();
                if !ITEMS.contains(&item_name) {
                    ITEMS.push(item_name);
                }
            }
        }
        None
    }
}

fn hash_file(path: &PathBuf) -> u64 {
    let mut hasher = DefaultHasher::new();
    std::fs::read(path).unwrap().hash(&mut hasher);
    println!("cargo:rerun-if-changed={}", path.to_string_lossy());
    hasher.finish()
}

fn read_cached_hash(cached_hash_path: &PathBuf) -> Option<u64> {
    if let Ok(hash) = std::fs::read(cached_hash_path) {
        return Some(u64::from_ne_bytes(hash.try_into().unwrap()));
    }
    None
}

fn save_cached_hash(hash: u64, cached_hash_path: &PathBuf) {
    std::fs::write(cached_hash_path, hash.to_ne_bytes()).unwrap();
}

// Verifies `vector_type_helpers.rs`.
pub fn main() {
    // TODO: Figure out a way to keep this in-sync with lib.rs
    let header = Path::new(METAL_BUILD_MANIFEST_DIR)
        .join("src")
        .join("rust_bindgen_only_metal_types.h");

    let cached_hash_path =
        PathBuf::from(env::var("OUT_DIR").unwrap()).join("rust_bindgen_only_metal_types_h_hash");
    let current_hash = hash_file(&header);
    if let Some(old_hash) = read_cached_hash(&cached_hash_path) {
        if old_hash == current_hash {
            return;
        }
    }

    bindgen::Builder::default()
        .header(header.to_string_lossy())
        .clang_arg("-xc++")
        .clang_arg("-std=c++17")
        .default_enum_style(bindgen::EnumVariation::Rust {
            non_exhaustive: false,
        })
        .derive_eq(true)
        .derive_debug(false)
        .no_debug("*")
        .parse_callbacks(Box::new(CollectItems::new()))
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(
            PathBuf::from(env::var("OUT_DIR").unwrap())
                .join("rust_bindgen_only_metal_type_bindings.rs"),
        )
        .expect("Failed to generate rust_bindgen_only_metal_type_bindings.rs");
    std::fs::write(
        Path::new(METAL_BUILD_MANIFEST_DIR)
            .join("src")
            .join("rust_bindgen_only_metal_types_list.rs"),
        unsafe {
            ITEMS.sort();
            let joined_items = ITEMS
                .iter()
                .map(|a| format!("\t\"{a}\",\n"))
                .collect::<String>();
            let num_items = ITEMS.len();
            format!(r#"/**************************************************************************************************
GENERATED FILE. DO NOT MODIFY.

This file is generated by the `build.rs`.
***************************************************************************************************/
pub const TYPES: [&'static str; {num_items}] = [
{joined_items}];
"#)
        },
    )
    .expect("Failed to write tmp.txt");
    save_cached_hash(current_hash, &cached_hash_path);
}
