use bindgen::{callbacks::ParseCallbacks, CargoCallbacks};
use std::{env, fmt::Debug, fs, io::Write, path::Path};

const METAL_BUILD_MANIFEST_DIR: &'static str = env!("CARGO_MANIFEST_DIR");

static mut ITEMS: Vec<String> = Vec::new();

#[derive(Debug)]
struct CollectItems {
    cargo_callbacks: CargoCallbacks,
}

impl CollectItems {
    fn new() -> Self {
        Self {
            cargo_callbacks: CargoCallbacks,
        }
    }
}

impl ParseCallbacks for CollectItems {
    fn include_file(&self, filename: &str) {
        self.cargo_callbacks.include_file(filename);
    }
    fn item_name(&self, item_name: &str) -> Option<String> {
        if item_name != "root" {
            unsafe {
                let item_name = item_name.to_owned();
                if !ITEMS.contains(&item_name) {
                    ITEMS.push(item_name);
                }
            }
        }
        None
    }
}

// Verifies `rust_bindgen_only_metal_types_bindings.rs`.
pub fn main() {
    // TODO: Figure out a way to keep this in-sync with lib.rs
    let src_dir = Path::new(METAL_BUILD_MANIFEST_DIR).join("src");
    let header = src_dir.join("rust_bindgen_only_metal_types.h");
    build_hash::build_hash(
        src_dir.join("rust_bindgen_only_metal_types_h_hash"),
        &[&header],
        || {
            let mut rust_bindgen_only_metal_types_file = fs::File::options()
            .write(true)
            .truncate(true)
            .create(true)
            .open(&src_dir.join("rust_bindgen_only_metal_types.rs"))
            .expect("Could not create rust_bindgen_only_metal_types.rs containing Rust bindings for types in src/rust_bindgen_only_metal_types.h");

            bindgen::Builder::default()
                .header(header.to_string_lossy())
                .clang_arg("-xc++")
                .clang_arg("-std=c++17")
                .default_enum_style(bindgen::EnumVariation::Rust {
                    non_exhaustive: false,
                })
                .derive_eq(true)
                .derive_copy(true)
                .derive_debug(false)
                .no_debug("*")
                .parse_callbacks(Box::new(CollectItems::new()))
                .generate()
                .expect("Unable to generate bindings")
                .write(Box::new(&rust_bindgen_only_metal_types_file))
                .expect("Failed to generate rust_bindgen_only_metal_types.rs");
            unsafe {
                ITEMS.sort();
            }

            // Generate tests to verify all Metal Types derive Copy/Clone.
            let mut w =
                |s: &str| {
                    rust_bindgen_only_metal_types_file.write_all(s.as_bytes()).expect(
                    "Failed to generate tests verifying all generated Rust types implement Copy",
                );
                };
            w("
#[test]
fn test_metal_types_derive_copy() {
    use std::marker::PhantomData;
    struct HasCopyClone<T: Sized + Copy + Clone>(PhantomData<T>);");
            for item in unsafe { &ITEMS } {
                w(&format!(
                    r"
    HasCopyClone(PhantomData::<{item}>);"
                ));
            }
            w("
}");
            std::fs::write(
    src_dir
        .join("rust_bindgen_only_metal_types_list.rs"),
    unsafe {
        let joined_items = ITEMS
            .iter()
            .map(|a| format!("\t\"{a}\",\n"))
            .collect::<String>();
        let num_items = ITEMS.len();
        format!(r#"/**************************************************************************************************
GENERATED FILE. DO NOT MODIFY.

This file is generated by the `build.rs`.
***************************************************************************************************/
pub const TYPES: [&'static str; {num_items}] = [
{joined_items}];
"#)
    },
)
.expect("Failed to write tmp.txt");
        },
    );
}
