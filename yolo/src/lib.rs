#![feature(generic_associated_types)]
#![feature(portable_simd)]
use metal_app::{
    metal::*,
    metal_types::*,
    pipeline::{bind::*, function, pipeline_function::*, render_pipeline::*},
    typed_buffer::*,
    DEFAULT_RESOURCE_OPTIONS,
};
use std::simd::f32x4;

// Assumed to be generated by metal-build (shader_function_parser/generate_shader_binds)
struct Vertex1Binds<'a> {
    v_bind1: BindMany<'a, f32>,
    v_bind2: BindMany<'a, f32>,
    v_bind3: BindMany<'a, f32>,
    v_bind4: BindMany<'a, f32>,
}
impl Binds for Vertex1Binds<'_> {
    #[inline(always)]
    fn bind<F: PipelineFunctionType>(self, encoder: &F::CommandEncoder) {
        self.v_bind1.bind::<F>(encoder, 0);
        self.v_bind2.bind::<F>(encoder, 1);
        self.v_bind3.bind::<F>(encoder, 2);
        self.v_bind4.bind::<F>(encoder, 4);
    }
}

struct Vertex1 {
    function_constant_1: bool,
}
impl function::Function for Vertex1 {
    const FUNCTION_NAME: &'static str = "vertex1";
    type Binds<'a> = Vertex1Binds<'a>;
    #[inline(always)]
    fn get_function_constants(&self) -> Option<FunctionConstantValues> {
        let fcv = FunctionConstantValues::new();
        fcv.set_constant_value_at_index(
            (&self.function_constant_1 as *const _) as _,
            bool::MTL_DATA_TYPE,
            1,
        );
        Some(fcv)
    }
}
impl PipelineFunction<VertexFunctionType> for Vertex1 {}

// Assumed to be generated by metal-build (shader_function_parser/generate_shader_binds)
struct Frag1Binds<'a> {
    f_bind1: Bind<'a, float4>,
    f_tex2: BindTexture<'a>,
}
impl Binds for Frag1Binds<'_> {
    #[inline(always)]
    fn bind<F: PipelineFunctionType>(self, encoder: &F::CommandEncoder) {
        self.f_bind1.bind::<F>(encoder, 0);
        self.f_tex2.bind::<F>(encoder, 1);
    }
}
struct Fragment1 {
    function_constant_2: bool,
}
impl function::Function for Fragment1 {
    const FUNCTION_NAME: &'static str = "fragment1";
    type Binds<'a> = Frag1Binds<'a>;

    #[inline(always)]
    fn get_function_constants(&self) -> Option<FunctionConstantValues> {
        let fcv = FunctionConstantValues::new();
        fcv.set_constant_value_at_index(
            (&self.function_constant_2 as *const _) as _,
            bool::MTL_DATA_TYPE,
            1,
        );
        Some(fcv)
    }
}
impl PipelineFunction<FragmentFunctionType> for Fragment1 {}

pub fn run() {
    let device = Device::system_default().expect("Failed to get Metal Device");
    let lib = device.new_default_library();
    let command_queue = device.new_command_queue();
    let command_buffer = command_queue.new_command_buffer();

    let texture = device.new_texture(&TextureDescriptor::new());
    let color1 = &texture;

    let f32_buffer = TypedBuffer::<f32>::with_capacity(
        "f32_buffer",
        &device as &DeviceRef,
        1,
        DEFAULT_RESOURCE_OPTIONS,
    );
    let float4_buffer = TypedBuffer::<float4>::with_capacity(
        "float4_buffer",
        &device as &DeviceRef,
        1,
        DEFAULT_RESOURCE_OPTIONS,
    );

    let p: RenderPipeline<1, Vertex1, Fragment1, NoDepth, NoStencil> = RenderPipeline::new(
        "Test",
        &device,
        &lib,
        [(MTLPixelFormat::BGRA8Unorm, BlendMode::NoBlend)],
        Vertex1 {
            function_constant_1: true,
        },
        Fragment1 {
            function_constant_2: true,
        },
        NoDepth,
        NoStencil,
    );
    let pass = p.new_pass(
        "test label",
        command_buffer,
        [(
            color1,
            (0., 0., 0., 0.),
            MTLLoadAction::Clear,
            MTLStoreAction::Store,
        )],
        NoDepth,
        NoStencil,
    );
    pass.bind(
        Vertex1Binds {
            v_bind1: BindMany::Values(&[0.]),
            v_bind2: BindMany::Values(&[1.]),
            v_bind3: BindMany::Values(&[2.]),
            v_bind4: BindMany::Values(&[3.]),
        },
        Frag1Binds {
            f_bind1: Bind::Value(&f32x4::from_array([1.; 4]).into()),
            f_tex2: BindTexture(&texture),
        },
    );
    use BindBuffer::*;
    pass.bind(
        Vertex1Binds {
            v_bind1: BindMany::Buffer(WithOffset(&f32_buffer, 0)),
            v_bind2: BindMany::Buffer(WithOffset(&f32_buffer, 1)),
            v_bind3: BindMany::Buffer(WithOffset(&f32_buffer, 2)),
            v_bind4: BindMany::Buffer(WithOffset(&f32_buffer, 3)),
        },
        Frag1Binds {
            f_bind1: Bind::Buffer(WithOffset(&float4_buffer, 0)),
            f_tex2: BindTexture(&texture),
        },
    );
}
