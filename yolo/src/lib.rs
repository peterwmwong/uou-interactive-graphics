#![feature(generic_associated_types)]
#![feature(portable_simd)]
use metal_app::{
    metal::{
        Device, DeviceRef, FunctionConstantValues, MTLLoadAction, MTLPixelFormat, MTLStoreAction,
        RenderCommandEncoderRef, TextureDescriptor,
    },
    metal_types::*,
    render_pipeline::*,
    typed_buffer::*,
    DEFAULT_RESOURCE_OPTIONS,
};
use std::simd::f32x4;

// Assumed to be generated by metal-build (shader_function_parser/generate_shader_binds)
struct Vertex1Binds<'a> {
    v_bind1: BindMany<'a, f32>,
    v_bind2: BindMany<'a, f32>,
    v_bind3: BindMany<'a, f32>,
    v_bind4: BindMany<'a, f32>,
}
impl FunctionBinds for Vertex1Binds<'_> {
    fn encode_binds<E: BindEncoder>(self, encoder: &RenderCommandEncoderRef) {
        E::encode(encoder, self.v_bind1, 0);
        E::encode(encoder, self.v_bind2, 1);
        E::encode(encoder, self.v_bind3, 2);
        E::encode(encoder, self.v_bind4, 4);
    }
}
struct Vertex1 {
    function_constant_1: bool,
}
impl Function for Vertex1 {
    const FUNCTION_NAME: &'static str = "vertex1";
    type Binds<'a> = Vertex1Binds<'a>;
    type Type = VertexFunctionType;

    fn get_function_constants(&self) -> Option<FunctionConstantValues> {
        let fcv = FunctionConstantValues::new();
        fcv.set_constant_value_at_index(
            (&self.function_constant_1 as *const _) as _,
            bool::MTL_DATA_TYPE,
            1,
        );
        Some(fcv)
    }
}

// Assumed to be generated by metal-build (shader_function_parser/generate_shader_binds)
struct Frag1Binds<'a> {
    f_bind1: BindOne<'a, float4>,
    f_tex2: BindTexture<'a>,
}
impl FunctionBinds for Frag1Binds<'_> {
    fn encode_binds<E: BindEncoder>(self, encoder: &RenderCommandEncoderRef) {
        E::encode_one(encoder, self.f_bind1, 0);
        E::encode_texture(encoder, self.f_tex2, 1);
    }
}
struct Fragment1 {
    function_constant_2: bool,
}
impl Function for Fragment1 {
    const FUNCTION_NAME: &'static str = "fragment1";
    type Binds<'a> = Frag1Binds<'a>;
    type Type = FragmentFunctionType;

    fn get_function_constants(&self) -> Option<FunctionConstantValues> {
        let fcv = FunctionConstantValues::new();
        fcv.set_constant_value_at_index(
            (&self.function_constant_2 as *const _) as _,
            bool::MTL_DATA_TYPE,
            1,
        );
        Some(fcv)
    }
}

pub fn run() {
    let device = Device::system_default().expect("Failed to get Metal Device");
    let lib = device.new_default_library();
    let command_queue = device.new_command_queue();
    let command_buffer = command_queue.new_command_buffer();

    let texture = device.new_texture(&TextureDescriptor::new());
    let color1 = &texture;

    let f32_buffer = TypedBuffer::<f32>::with_capacity(
        "f32_buffer",
        &device as &DeviceRef,
        1,
        DEFAULT_RESOURCE_OPTIONS,
    );
    let float4_buffer = TypedBuffer::<float4>::with_capacity(
        "float4_buffer",
        &device as &DeviceRef,
        1,
        DEFAULT_RESOURCE_OPTIONS,
    );

    let p: RenderPipeline<1, Vertex1, Fragment1, NoDepth, NoStencil> = RenderPipeline::new(
        "Test",
        &device,
        &lib,
        [(MTLPixelFormat::BGRA8Unorm, BlendMode::NoBlend)],
        Vertex1 {
            function_constant_1: true,
        },
        Fragment1 {
            function_constant_2: true,
        },
        NoDepth,
        NoStencil,
    );
    let encoder = p.new_render_command_encoder(
        "test label",
        command_buffer,
        [(
            color1,
            (0., 0., 0., 0.),
            MTLLoadAction::Clear,
            MTLStoreAction::Store,
        )],
        NoDepth,
        NoStencil,
    );
    p.bind(
        encoder,
        Vertex1Binds {
            v_bind1: BindMany::Bytes(&[0.]),
            v_bind2: BindMany::Bytes(&[1.]),
            v_bind3: BindMany::Bytes(&[2.]),
            v_bind4: BindMany::Bytes(&[3.]),
        },
        Frag1Binds {
            f_bind1: BindOne::Bytes(&f32x4::from_array([1.; 4]).into()),
            f_tex2: BindTexture(&texture),
        },
    );
    p.bind(
        encoder,
        Vertex1Binds {
            v_bind1: BindMany::BufferAndOffset(&f32_buffer, 0),
            v_bind2: BindMany::BufferAndOffset(&f32_buffer, 1),
            v_bind3: BindMany::BufferAndOffset(&f32_buffer, 2),
            v_bind4: BindMany::BufferAndOffset(&f32_buffer, 3),
        },
        Frag1Binds {
            f_bind1: BindOne::BufferAndOffset(&float4_buffer, 0),
            f_tex2: BindTexture(&texture),
        },
    );
}
